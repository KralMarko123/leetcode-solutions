export const BEST_TIME_TO_BUY_AND_SELL_STOCK_APPROACH = `From the text I realize that there are a few things I want to remember. Since each i resembles a day, I should save the day on which the stock is cheapest, as well as the maximum profit found.\n\nGoing with the assumption that there are at least two days to go through, the scenario where we can only buy and sell in the same day means a profit of 0. The profit is calculated by subtracting the price that's for the current day with the cheapest price found up until that point. Using the previously stored variable to remember any found profits, I check it against the current profit. If the current profit is bigger, then set that as the max profit found.\n\nI also check if the price the stock is at currently is the cheapest one we've found so far, if so, set that as the cheapest day.
`;

export const BINARY_SEARCH_APPROACH = `This problem is simple enough. The main catch is that the time complexity is required to be faster than O(N), and as the title implies, a binary search is supposed to be used. So while C# provides us with a built-in implementation of the binary search, I wrote my own as well.\n\nThe method splits the array and checks if the target is found, if not, check whether it's in the first, or the second piece of the split (by checking whether the value is higher or lower than the one we're at). By constantly splitting the pieces, I eventually get to the target value or run out of pieces to split.`;

export const ARITHMETIC_PROGRESSION_APPROACH = `This problem involved some thinking about how to find if the difference is the same everywhere. One approach is to loop through each element and check if the difference remains the same after the elements have been sorted. But this introduces more time complexity by doing sorting. The solution was to use a set, and to check if the maximum difference can be divided equally (meaning the differences between adjacent elements can be equal).`;

export const LONGEST_CONSECUTIVE_SEQUENCE_APPROACH = `The main constraint is the O(N) time complexity. Since the elements aren't sorted I had to find a way to try and remember the sequences being passed but from the location of each number. The solution was to transform the number array into a set which we can check directly for a value without having to loop over again. With each number passed we check for an existing sequence and we continue that sequence until we reach its end, and then remember that sequence's length if it was the longest. In order to have the actual algorithm be O(N), we have to check if a previous number contained in a sequence was passed. That way, the worst case scenario would be for the first number to be the smallest and the last one to be the largest, resulting in O(N + N - 1), which is still linear.`;

export const MIN_STACK_APPROACH = `I wanted to implement this without using the Stack class already provided. So I decided to go with two lists as my approach. One would keep all the minimal elements found whilst the other would keep all elements. Depending on what the method called is, we either return from one list or the other, and if a new value is added check if it's the smallest one yet to add it to the list with minimal elements.`;

export const CAN_PLACE_FLOWERS_APPROACH = `This problem is pretty much one big if-statement. Since the rule clearly states that we can't plant our flowers in adjacent plots, that's obviously one of the extra checks, with the other extra check being if we are at the beggining or at the end. And if all of those combinations result to true, just fill the plot and decrement the number of flowers.\n\nIf we're left with anything equal to or lower than 0, then we can definitely plant our flowers.`;
